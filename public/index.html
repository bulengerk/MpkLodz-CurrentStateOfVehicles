<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MPK Łódź – Pozycje pojazdów w czasie rzeczywistym</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: #f5f5f5;
    }

    #map {
      position: relative;
      z-index: 1;
    }

    #refresh-info {
      position: fixed;
      top: 16px;
      right: 16px;
      z-index: 1000;
      padding: 8px 12px;
      background: rgba(33, 33, 33, 0.85);
      color: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      font-size: 14px;
      letter-spacing: 0.2px;
    }

    #controls {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 1000;
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      font-size: 14px;
    }

    #controls label {
      font-weight: 600;
      color: #1b5e20;
    }

    #controls input {
      min-width: 120px;
      padding: 6px 8px;
      border: 1px solid #cfd8dc;
      border-radius: 4px;
      font-size: 14px;
    }

    #controls button {
      padding: 6px 10px;
      border: none;
      border-radius: 4px;
      background: #1b5e20;
      color: #fff;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s ease;
    }

    #controls button:hover {
      background: #145316;
    }

    .vehicle-marker {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      transform: translate(-50%, -50%);
    }

    .vehicle-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
    }

    .vehicle-icon svg {
      width: 32px;
      height: 32px;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.35));
    }

    .route-label {
      display: none;
      margin-top: 2px;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.65);
      pointer-events: none;
      line-height: 1;
      padding: 3px 6px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.6);
      white-space: nowrap;
    }

    .map-show-route-labels .route-label {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="route-filter">Pokaż linię</label>
    <input id="route-filter" type="text" placeholder="np. 52 lub 1" autocomplete="off">
    <button id="clear-route-filter" type="button">Pokaż wszystkie</button>
  </div>
  <div id="map"></div>
  <div id="refresh-info">Ładowanie danych pojazdów…</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([51.759, 19.458], 12);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
    }).addTo(map);

    const markers = {};
    const refreshInfo = document.getElementById('refresh-info');
    const routeFilterInput = document.getElementById('route-filter');
    const clearFilterButton = document.getElementById('clear-route-filter');
    const DEFAULT_INTERVAL_MS = 15000;
    const FOCUSED_INTERVAL_MS = 5000;
    const LABEL_ZOOM_THRESHOLD = 15;
    let refreshTimer = null;
    let isFetching = false;
    let pendingImmediateUpdate = false;
    let activeRouteFilter = '';
    let activeRouteFilterLabel = '';
    const raf = window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : (callback) => setTimeout(() => callback(Date.now()), 16);
    const caf = window.cancelAnimationFrame
      ? window.cancelAnimationFrame.bind(window)
      : clearTimeout;
    const ROUTE_TOOLTIP_OPTIONS = {
      direction: 'top',
      offset: [0, -30],
      opacity: 0.85,
      sticky: false
    };

    function normalizeRoute(value) {
      return (value || '').toString().trim().toUpperCase();
    }

    function possibleRoutesFromLabel(value) {
      const normalized = normalizeRoute(value);
      if (!normalized) return [];
      return normalized.split(/[^A-Z0-9]+/).filter(Boolean);
    }

    function matchesActiveFilter(vehicle) {
      if (!activeRouteFilter) return true;
      const route = normalizeRoute(vehicle.routeId);
      if (route && route === activeRouteFilter) return true;
      const labelTokens = possibleRoutesFromLabel(vehicle.label);
      return labelTokens.includes(activeRouteFilter);
    }

    function deriveRouteLabel(vehicle) {
      const route = normalizeRoute(vehicle.routeId);
      if (route) return route;
      const labelTokens = possibleRoutesFromLabel(vehicle.label);
      if (!labelTokens.length) return '';
      const tokenWithDigit = labelTokens.find(token => /\d/.test(token));
      return tokenWithDigit || labelTokens[0];
    }

    function setMarkerVisibility(entry, shouldShow) {
      if (shouldShow) {
        if (!entry.isVisible) {
          entry.marker.addTo(map);
          entry.isVisible = true;
          if (entry.lastLatLng) {
            entry.marker.setLatLng([entry.lastLatLng.lat, entry.lastLatLng.lng]);
          }
        }
        return;
      }

      if (entry.isVisible !== false) {
        cancelAnimation(entry);
        entry.marker.remove();
        entry.isVisible = false;
      }
    }

    function applyFilterToExistingMarkers() {
      Object.values(markers).forEach(entry => {
        if (!entry.lastVehicle) return;
        setMarkerVisibility(entry, matchesActiveFilter(entry.lastVehicle));
      });
    }

    function setRouteFilter(rawValue) {
      const display = (rawValue || '').trim();
      const normalized = normalizeRoute(display);
      if (activeRouteFilter === normalized && activeRouteFilterLabel === display) return;
      activeRouteFilter = normalized;
      activeRouteFilterLabel = display;
      applyFilterToExistingMarkers();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
      pendingImmediateUpdate = true;
      if (!isFetching) updatePositions();
    }

    const busSvg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='10' y='14' width='44' height='32' rx='10' ry='10' fill='#c62828' stroke='#5d1010' stroke-width='2'/><rect x='16' y='18' width='32' height='14' rx='3' fill='#fbe9e7'/><rect x='14' y='34' width='36' height='8' rx='3' fill='#6d4c41'/><circle cx='22' cy='50' r='6' fill='#263238'/><circle cx='42' cy='50' r='6' fill='#263238'/><rect x='24' y='8' width='16' height='4' rx='2' fill='#5d1010'/><circle cx='18' cy='30' r='3' fill='#ffab40'/><circle cx='46' cy='30' r='3' fill='#ffab40'/></svg>`;

    const tramSvg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect x='12' y='16' width='40' height='28' rx='12' ry='12' fill='#1565c0' stroke='#0d47a1' stroke-width='2'/><rect x='18' y='20' width='28' height='12' rx='3' fill='#e3f2fd'/><rect x='20' y='34' width='24' height='6' rx='2' fill='#1e88e5'/><circle cx='22' cy='50' r='5' fill='#212121'/><circle cx='42' cy='50' r='5' fill='#212121'/><rect x='28' y='10' width='8' height='6' rx='3' fill='#0d47a1'/><path d='M18 52h28' stroke='#90a4ae' stroke-width='3' stroke-linecap='round'/></svg>`;

    function createVehicleIcon(vehicle) {
      const isTramVehicle = isTram(vehicle);
      const type = isTramVehicle ? 'tram' : 'bus';
      const svgMarkup = isTramVehicle ? tramSvg : busSvg;
      const label = deriveRouteLabel(vehicle);
      const labelHtml = label ? `<span class="route-label">${label}</span>` : '';
      return L.divIcon({
        html: `<div class="vehicle-marker ${type}"><div class="vehicle-icon">${svgMarkup}</div>${labelHtml}</div>`,
        className: '',
        iconSize: [36, 48],
        iconAnchor: [18, 24],
        popupAnchor: [0, -24]
      });
    }

    const TRAM_ROUTES = new Set([
      '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '11A', '11B',
      '12', '14', '15', '16', '17', '41'
    ]);

    function isTram(vehicle) {
      const route = (vehicle.routeId || '').toString().toUpperCase();
      if (route && TRAM_ROUTES.has(route)) return true;
      const label = (vehicle.label || '').toString();
      return /TRAM/i.test(label);
    }

    function iconForVehicle(vehicle) {
      return createVehicleIcon(vehicle);
    }

    function currentInterval() {
      const zoom = map.getZoom();
      return zoom >= 15 ? FOCUSED_INTERVAL_MS : DEFAULT_INTERVAL_MS;
    }

    function updateRouteLabelVisibility() {
      const container = map.getContainer();
      if (!container) return;
      if (map.getZoom() >= LABEL_ZOOM_THRESHOLD) {
        container.classList.add('map-show-route-labels');
      } else {
        container.classList.remove('map-show-route-labels');
      }
    }

    function formatRefreshInfo(lastSuccess, interval, statusText) {
      const seconds = Math.round(interval / 1000);
      let text = `Odświeżanie mapy: co ${seconds} s`;
      if (!lastSuccess) {
        text += ' | ostatnia aktualizacja: oczekiwanie…';
      } else {
        text += ` | ostatnia aktualizacja: ${lastSuccess.toLocaleTimeString('pl-PL')}`;
      }
      if (activeRouteFilterLabel) {
        text += ` | filtr: linia ${activeRouteFilterLabel}`;
      }
      if (statusText) {
        text += ` | ${statusText}`;
      }
      return text;
    }

    function scheduleNextUpdate() {
      if (refreshTimer) {
        clearTimeout(refreshTimer);
      }
      refreshTimer = setTimeout(updatePositions, currentInterval());
    }

    function shouldAnimate() {
      return map.getZoom() >= 15;
    }

    function cancelAnimation(entry) {
      if (entry.animationFrame) {
        caf(entry.animationFrame);
        entry.animationFrame = null;
      }
    }

    function animateMarker(entry, targetLatLng, interval) {
      cancelAnimation(entry);
      const startLatLng = entry.lastLatLng
        ? L.latLng(entry.lastLatLng.lat, entry.lastLatLng.lng)
        : entry.marker.getLatLng();
      const target = L.latLng(targetLatLng[0], targetLatLng[1]);
      const distanceMeters = map.distance(startLatLng, target);
      const minDuration = 600;
      const maxDuration = Math.min(Math.max(interval - 400, minDuration), 6000);
      const distanceDuration = (distanceMeters / 25) * 1000; // ~25 m/s cap
      const duration = Math.min(maxDuration, Math.max(minDuration, distanceDuration || minDuration));
      let startTime = null;

      function step(now) {
        if (startTime === null) startTime = now;
        const elapsed = now - startTime;
        const t = Math.min(1, elapsed / duration);
        const ease = t;
        const lat = startLatLng.lat + (target.lat - startLatLng.lat) * ease;
        const lng = startLatLng.lng + (target.lng - startLatLng.lng) * ease;
        entry.marker.setLatLng([lat, lng]);
        if (t < 1 && shouldAnimate()) {
          entry.animationFrame = raf(step);
        } else {
          entry.animationFrame = null;
          entry.lastLatLng = { lat: target.lat, lng: target.lng };
          entry.marker.setLatLng(targetLatLng);
        }
      }

      if (!shouldAnimate()) {
        entry.marker.setLatLng(targetLatLng);
        entry.lastLatLng = { lat: target.lat, lng: target.lng };
        return;
      }

      entry.animationFrame = raf(step);
    }

    let lastSuccessfulUpdate = null;
    refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
    updateRouteLabelVisibility();

    routeFilterInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        setRouteFilter(routeFilterInput.value);
      }
    });

    routeFilterInput.addEventListener('blur', () => {
      setRouteFilter(routeFilterInput.value);
    });

    routeFilterInput.addEventListener('input', () => {
      if (!routeFilterInput.value.trim()) {
        setRouteFilter('');
      }
    });

    clearFilterButton.addEventListener('click', () => {
      routeFilterInput.value = '';
      setRouteFilter('');
      routeFilterInput.focus();
    });

    async function updatePositions() {
      if (isFetching) {
        pendingImmediateUpdate = true;
        return;
      }
      isFetching = true;
      const interval = currentInterval();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, interval, 'pobieranie…');
      try {
        const res = await fetch(`/positions?ts=${Date.now()}`, { cache: 'no-store' });
        const data = await res.json();
        if (!Array.isArray(data)) return;
        data.forEach(vehicle => {
          const key = vehicle.id || vehicle.label || `${vehicle.lat},${vehicle.lon}`;
          if (!key) return;
          const latlng = [vehicle.lat, vehicle.lon];
          const routeLabel = deriveRouteLabel(vehicle);
          const icon = iconForVehicle(vehicle);
          const popupParts = [];
          if (vehicle.routeId) popupParts.push(`<strong>Linia:</strong> ${vehicle.routeId}`);
          if (vehicle.tripId) popupParts.push(`<strong>Trip:</strong> ${vehicle.tripId}`);
          if (vehicle.timestamp) {
            const date = new Date(vehicle.timestamp);
            popupParts.push(`<strong>Czas:</strong> ${date.toLocaleTimeString('pl-PL')}`);
          }
          const popupHtml = popupParts.join('<br>');
          const matchesFilter = matchesActiveFilter(vehicle);
          const existing = markers[key];
          if (existing) {
            existing.lastVehicle = vehicle;
            existing.marker.setIcon(icon);
            if (routeLabel) {
              existing.marker.bindTooltip(`Linia ${routeLabel}`, ROUTE_TOOLTIP_OPTIONS);
            } else if (existing.marker.getTooltip()) {
              existing.marker.unbindTooltip();
            }
            const popup = existing.marker.getPopup();
            if (popupHtml) {
              if (popup) {
                popup.setContent(popupHtml);
              } else {
                existing.marker.bindPopup(popupHtml);
              }
            } else if (popup) {
              popup.setContent('');
            }
            if (!matchesFilter) {
              existing.marker.setLatLng(latlng);
              existing.lastLatLng = { lat: latlng[0], lng: latlng[1] };
              setMarkerVisibility(existing, false);
              return;
            }
            setMarkerVisibility(existing, true);
            if (shouldAnimate()) {
              animateMarker(existing, latlng, interval);
            } else {
              cancelAnimation(existing);
              existing.marker.setLatLng(latlng);
              existing.lastLatLng = { lat: latlng[0], lng: latlng[1] };
            }
            return;
          }

          if (!matchesFilter) return;

          const marker = L.marker(latlng, { icon });
          if (popupHtml) {
            marker.bindPopup(popupHtml);
          }
          if (routeLabel) {
            marker.bindTooltip(`Linia ${routeLabel}`, ROUTE_TOOLTIP_OPTIONS);
          }
          marker.addTo(map);
          markers[key] = {
            marker,
            lastLatLng: { lat: latlng[0], lng: latlng[1] },
            animationFrame: null,
            isVisible: true,
            lastVehicle: vehicle
          };
        });
        lastSuccessfulUpdate = new Date();
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, interval);
      } catch (err) {
        console.error('Błąd podczas pobierania pozycji pojazdów:', err);
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'błąd pobierania');
      } finally {
        isFetching = false;
        if (pendingImmediateUpdate) {
          pendingImmediateUpdate = false;
          setTimeout(updatePositions, 0);
        } else {
          scheduleNextUpdate();
        }
      }
    }

    map.on('zoomend', () => {
      updateRouteLabelVisibility();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
      updatePositions();
    });

    updatePositions();
  </script>
</body>
</html>
