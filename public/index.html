<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MPK Łódź – Pozycje pojazdów w czasie rzeczywistym</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: #f5f5f5;
    }

    #map {
      position: relative;
      z-index: 1;
      margin-top: 70px;
    }

    #refresh-info {
      display: block;
      margin-top: 4px;
      font-size: 11px;
      color: #37474f;
      letter-spacing: 0.2px;
    }

    #top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      display: flex;
      justify-content: center;
      pointer-events: none;
    }

    #controls {
      margin: 12px auto 0;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 999px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
      font-size: 13px;
      flex-wrap: nowrap;
      pointer-events: auto;
    }

    #controls input {
      min-width: 150px;
      padding: 6px 12px;
      border: 1px solid #cfd8dc;
      border-radius: 999px;
      font-size: 13px;
      flex: 1 1 auto;
      background: rgba(255, 255, 255, 0.9);
    }

    #controls button {
      padding: 6px 12px;
      border: none;
      border-radius: 999px;
      background: #1b5e20;
      color: #fff;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s ease;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    #controls button:hover {
      background: #145316;
    }

    #map {
      position: relative;
      z-index: 1;
      margin-top: 70px;
    }

    .vehicle-marker {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      transform: translate(-50%, -50%);
    }

    .vehicle-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      transform: rotate(var(--heading, 0deg));
      transition: transform 0.4s ease-out;
    }

    .vehicle-icon svg {
      width: 32px;
      height: 32px;
      filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.35));
    }

    .route-label {
      display: none;
      margin-top: 2px;
      font-size: 13px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.65);
      pointer-events: none;
      line-height: 1;
      padding: 3px 6px;
      border-radius: 12px;
      background: rgba(0, 0, 0, 0.6);
      white-space: nowrap;
    }

    .map-show-route-labels .route-label {
      display: inline-block;
    }

    #data-attribution {
      position: fixed;
      bottom: 6px;
      right: 10px;
      z-index: 1000;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.85);
      color: #263238;
      border-radius: 6px;
      font-size: 10px;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
      line-height: 1.3;
      min-width: 140px;
    }

    #data-attribution a {
      color: inherit;
      text-decoration: none;
      border-bottom: 1px dotted currentColor;
    }

    #data-attribution a:hover {
      text-decoration: underline;
    }

    #data-attribution .legend {
      margin-top: 4px;
      display: grid;
      gap: 2px;
      font-size: 9px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(0, 0, 0, 0.25);
      flex: 0 0 auto;
    }

    .legend-swatch.bus {
      background: #b08a5c;
    }

    .legend-swatch.tram {
      background: #60738f;
    }

    @media (max-width: 640px) {
      #top-bar {
        justify-content: stretch;
      }
      #controls {
        margin: 2px auto 0;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 3px 7px;
        border-radius: 12px;
        max-width: min(220px, calc(100% - 24px));
        background: rgba(255, 255, 255, 0.82);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      }
      #controls input {
        width: 100%;
        padding: 4px 7px;
        border-radius: 10px;
        font-size: 11px;
      }
      #controls button {
        width: 100%;
        padding: 4px 7px;
        border-radius: 10px;
        font-size: 10px;
      }
      #map {
        margin-top: 85px;
      }
      #data-attribution {
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        min-width: 130px;
        padding: 3px 6px;
        text-align: center;
        font-size: 9px;
        line-height: 1.2;
      }
      #data-attribution .legend {
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 1px 6px;
      }
      .legend-item {
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="top-bar">
    <div id="controls">
      <input id="route-filter" type="text" placeholder="np. 52 lub 1" autocomplete="off">
      <button id="clear-route-filter" type="button">Pokaż wszystkie</button>
      <button id="locate-user" type="button">Lokalizuj</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="data-attribution">
    <div>Dane: <a href="https://otwarte.miasto.lodz.pl/" target="_blank" rel="noopener">otwarte.miasto.lodz.pl</a></div>
    <span id="refresh-info">Ładowanie danych pojazdów…</span>
    <div class="legend">
      <div class="legend-item"><span class="legend-swatch bus"></span>Bus</div>
      <div class="legend-item"><span class="legend-swatch tram"></span>Tram</div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([51.759, 19.458], 12);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
    }).addTo(map);

    const markers = {};
    const refreshInfo = document.getElementById('refresh-info');
    const routeFilterInput = document.getElementById('route-filter');
    const clearFilterButton = document.getElementById('clear-route-filter');
    const locateButton = document.getElementById('locate-user');
    const DEFAULT_INTERVAL_MS = 14000;
    const FOCUSED_INTERVAL_MS = 3000;
    const FILTERED_INTERVAL_MS = 2500;
    const LABEL_ZOOM_THRESHOLD = 15;
    const MOTION_MIN_DURATION_MS = 400;
    const MOTION_MAX_DURATION_MS = 6000;
    const MOTION_PROJECTION_MS = 2500;
    const MOTION_PROJECTION_FACTOR = 1.25;
    const MOTION_MAX_PROJECTION_MS = 5000;
    const MAX_INTERPOLATION_SPEED_M_S = 18; // ~65 km/h
    const USER_LOCATION_ZOOM = 16;
    const USER_LOCATION_RADIUS_METERS = 30;
    let refreshTimer = null;
    let isFetching = false;
    let pendingImmediateUpdate = false;
    let activeRouteFilter = '';
    let activeRouteFilterLabel = '';
    let lastETag = null;
    let lastServerTimestamp = null;
    let userLocationMarker = null;
    const raf = window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : (callback) => setTimeout(() => callback(Date.now()), 16);
    const caf = window.cancelAnimationFrame
      ? window.cancelAnimationFrame.bind(window)
      : clearTimeout;
    const ROUTE_TOOLTIP_OPTIONS = {
      direction: 'top',
      offset: [0, -30],
      opacity: 0.85,
      sticky: false
    };
    const iconCache = new Map();

    function normalizeRoute(value) {
      return (value || '').toString().trim().toUpperCase();
    }

    function extractDirection(vehicle) {
      if (!vehicle) return '';
      const headsign = vehicle.headsign
        || (vehicle.trip && (vehicle.trip.tripHeadsign
          || vehicle.trip.trip_headsign
          || vehicle.trip.headsign
          || vehicle.trip.tripDestination
          || vehicle.trip.destination))
        || null;
      if (!headsign) return '';
      return headsign.toString().trim();
    }

    function possibleRoutesFromLabel(value) {
      const normalized = normalizeRoute(value);
      if (!normalized) return [];
      return normalized.split(/[^A-Z0-9]+/).filter(Boolean);
    }

    function tokenMatchesActiveFilter(token) {
      if (!activeRouteFilter) return true;
      const normalizedToken = normalizeRoute(token);
      if (!normalizedToken) return false;
      if (normalizedToken === activeRouteFilter) return true;
      const filterNumericOnly = /^[0-9]+$/.test(activeRouteFilter);
      if (filterNumericOnly && normalizedToken.startsWith(activeRouteFilter)) {
        return true;
      }
      return false;
    }

    function matchesActiveFilter(vehicle) {
      if (!activeRouteFilter) return true;
      const route = normalizeRoute(vehicle.routeId);
      if (tokenMatchesActiveFilter(route)) return true;
      const labelTokens = possibleRoutesFromLabel(vehicle.label);
      return labelTokens.some(tokenMatchesActiveFilter);
    }

    function deriveRouteLabel(vehicle) {
      const route = normalizeRoute(vehicle.routeId);
      if (route) return route;
      const labelTokens = possibleRoutesFromLabel(vehicle.label);
      if (!labelTokens.length) return '';
      const tokenWithDigit = labelTokens.find(token => /\d/.test(token));
      return tokenWithDigit || labelTokens[0];
    }

    function setMarkerVisibility(entry, shouldShow) {
      if (shouldShow) {
        if (!entry.isVisible) {
          entry.marker.addTo(map);
          const visibleLatLng = currentLatLng(entry);
          if (visibleLatLng) {
            entry.marker.setLatLng([visibleLatLng.lat, visibleLatLng.lng]);
          }
          if (entry.heading != null) {
            updateMarkerHeading(entry, entry.heading);
          }
        }
        entry.isVisible = true;
        return;
      }

      if (entry.isVisible) {
        entry.marker.remove();
      }
      entry.isVisible = false;
    }

    function applyFilterToExistingMarkers() {
      Object.values(markers).forEach(entry => {
        if (!entry.lastVehicle) return;
        setMarkerVisibility(entry, matchesActiveFilter(entry.lastVehicle));
      });
    }

    function setRouteFilter(rawValue) {
      const display = (rawValue || '').trim();
      const normalized = normalizeRoute(display);
      if (activeRouteFilter === normalized && activeRouteFilterLabel === display) return;
      activeRouteFilter = normalized;
      activeRouteFilterLabel = display;
      applyFilterToExistingMarkers();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
      pendingImmediateUpdate = true;
      if (!isFetching) updatePositions();
    }


    const busSvg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><defs><linearGradient id='busFront' x1='0%' y1='0%' x2='0%' y2='100%'><stop offset='0%' stop-color='#cbb38d'/><stop offset='100%' stop-color='#9c7d55'/></linearGradient><linearGradient id='busGrill' x1='0%' y1='0%' x2='100%' y2='0%'><stop offset='0%' stop-color='#5c4734'/><stop offset='100%' stop-color='#81664a'/></linearGradient></defs><rect x='12' y='16' width='40' height='30' rx='6' ry='6' fill='url(#busFront)' stroke='#4b3826' stroke-width='2'/><rect x='16' y='20' width='32' height='14' rx='3' ry='3' fill='#f6f2e8' stroke='#6d5439' stroke-width='1'/><rect x='18' y='36' width='28' height='6' rx='2' fill='url(#busGrill)'/><circle cx='22' cy='50' r='5.5' fill='#2f261c' stroke='#d9c9af' stroke-width='1'/><circle cx='42' cy='50' r='5.5' fill='#2f261c' stroke='#d9c9af' stroke-width='1'/><circle cx='18' cy='28' r='2.2' fill='#e2c88f'/><circle cx='46' cy='28' r='2.2' fill='#e2c88f'/><path d='M24 12h16' stroke='#4b3826' stroke-width='3' stroke-linecap='round'/><path d='M18 42h28' stroke='#6f563c' stroke-width='1.5' stroke-linecap='round'/></svg>`;

    const tramSvg = `<?xml version='1.0' encoding='UTF-8'?><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><defs><linearGradient id='tramShell' x1='0%' y1='0%' x2='0%' y2='100%'><stop offset='0%' stop-color='#94a3b8'/><stop offset='100%' stop-color='#4b5d78'/></linearGradient><linearGradient id='tramAccent' x1='0%' y1='0%' x2='100%' y2='0%'><stop offset='0%' stop-color='#e9d8b4'/><stop offset='100%' stop-color='#c8b07f'/></linearGradient></defs><rect x='8' y='16' width='48' height='28' rx='8' ry='8' fill='url(#tramShell)' stroke='#2f3f55' stroke-width='2'/><rect x='12' y='20' width='40' height='12' rx='2' ry='2' fill='#f4f1e7' stroke='#44566f' stroke-width='1'/><rect x='16' y='36' width='32' height='6' rx='2' fill='url(#tramAccent)' stroke='#8c734c' stroke-width='1'/><circle cx='20' cy='50' r='4.8' fill='#1f232a' stroke='#d5d9e0' stroke-width='1'/><circle cx='44' cy='50' r='4.8' fill='#1f232a' stroke='#d5d9e0' stroke-width='1'/><path d='M14 52h36' stroke='#5b6f8a' stroke-width='3' stroke-linecap='round'/></svg>`;

    function getVehicleIcon(vehicle) {
      const isTramVehicle = isTram(vehicle);
      const type = isTramVehicle ? 'tram' : 'bus';
      const svgMarkup = isTramVehicle ? tramSvg : busSvg;
      const label = deriveRouteLabel(vehicle);
      const cacheKey = `${type}|${label}`;
      if (iconCache.has(cacheKey)) {
        return { icon: iconCache.get(cacheKey), key: cacheKey, label };
      }
      const labelHtml = label ? `<span class="route-label">${label}</span>` : '';
      const icon = L.divIcon({
        html: `<div class="vehicle-marker ${type}"><div class="vehicle-icon">${svgMarkup}</div>${labelHtml}</div>`,
        className: '',
        iconSize: [36, 48],
        iconAnchor: [18, 24],
        popupAnchor: [0, -24]
      });
      iconCache.set(cacheKey, icon);
      return { icon, key: cacheKey, label };
    }

    const TRAM_ROUTES = new Set([
      '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '11A', '11B',
      '12', '14', '15', '16', '17', '41'
    ]);

    function isTram(vehicle) {
      const route = (vehicle.routeId || '').toString().toUpperCase();
      if (route && TRAM_ROUTES.has(route)) return true;
      const label = (vehicle.label || '').toString();
      return /TRAM/i.test(label);
    }

    function iconForVehicle(vehicle) {
      return getVehicleIcon(vehicle);
    }

    function vehicleTimestampMs(vehicle, fallback) {
      if (!vehicle.timestamp) return fallback;
      const numeric = Number(vehicle.timestamp);
      if (Number.isFinite(numeric)) {
        if (numeric > 1e12) return numeric;
        if (numeric > 1e9) return numeric * 1000;
      }
      const parsed = Date.parse(vehicle.timestamp);
      return Number.isNaN(parsed) ? fallback : parsed;
    }

    function clamp01(value) {
      return Math.min(1, Math.max(0, value));
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    function normalizeBearing(value) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric)) return null;
      const wrapped = numeric % 360;
      return wrapped < 0 ? wrapped + 360 : wrapped;
    }

    function updateMarkerHeading(entry, bearing) {
      const normalized = normalizeBearing(bearing);
      entry.heading = normalized;
      const applyHeading = () => {
        const element = entry.marker.getElement();
        if (!element) return false;
        const iconEl = element.querySelector('.vehicle-icon');
        if (!iconEl) return false;
        if (normalized == null) {
          iconEl.style.removeProperty('--heading');
        } else {
          iconEl.style.setProperty('--heading', `${normalized}deg`);
        }
        return true;
      };
      if (!applyHeading()) {
        entry.marker.once('add', () => updateMarkerHeading(entry, normalized));
      }
    }

    function durationForMotion(previousTimestamp, sampleTimestamp, fallbackDuration) {
      if (!previousTimestamp || !Number.isFinite(previousTimestamp)) {
        return fallbackDuration;
      }
      const delta = sampleTimestamp - previousTimestamp;
      if (!Number.isFinite(delta) || delta <= 0) {
        return fallbackDuration;
      }
      return Math.min(MOTION_MAX_DURATION_MS, Math.max(MOTION_MIN_DURATION_MS, delta));
    }

    function currentLatLng(entry) {
      if (entry.motion && entry.motion.currentLatLng) return entry.motion.currentLatLng;
      if (entry.lastLatLng) return entry.lastLatLng;
      if (!entry.marker) return null;
      const markerLatLng = entry.marker.getLatLng();
      return markerLatLng ? { lat: markerLatLng.lat, lng: markerLatLng.lng } : null;
    }

    function scheduleMotion(entry, targetLatLng, sampleTimestamp, previousSampleTimestamp, intervalMs) {
      const now = Date.now();
      const startLatLng = currentLatLng(entry) || { lat: targetLatLng[0], lng: targetLatLng[1] };
      const distanceMeters = map.distance(
        L.latLng(startLatLng.lat, startLatLng.lng),
        L.latLng(targetLatLng[0], targetLatLng[1])
      );
      if (!isFinite(distanceMeters) || distanceMeters < 0.5) {
        entry.motion = null;
        entry.lastLatLng = { lat: targetLatLng[0], lng: targetLatLng[1] };
        if (entry.isVisible !== false) {
          entry.marker.setLatLng(targetLatLng);
        }
        return;
      }

      const fallbackDuration = Math.min(MOTION_MAX_DURATION_MS, Math.max(MOTION_MIN_DURATION_MS, intervalMs));
      const ageDuration = durationForMotion(previousSampleTimestamp, sampleTimestamp, fallbackDuration);
      const distanceDuration = Math.min(
        MOTION_MAX_DURATION_MS,
        Math.max(MOTION_MIN_DURATION_MS, (distanceMeters / MAX_INTERPOLATION_SPEED_M_S) * 1000)
      );
      const duration = Math.min(
        MOTION_MAX_DURATION_MS,
        Math.max(MOTION_MIN_DURATION_MS, Math.max(ageDuration, distanceDuration))
      );
      const targetTimeMs = now + duration;
      const projectionWindow = Math.min(
        MOTION_MAX_PROJECTION_MS,
        Math.max(MOTION_PROJECTION_MS, Math.max(MOTION_MIN_DURATION_MS, intervalMs) * MOTION_PROJECTION_FACTOR)
      );
      const velocity = {
        latPerMs: (targetLatLng[0] - startLatLng.lat) / duration,
        lngPerMs: (targetLatLng[1] - startLatLng.lng) / duration
      };
      entry.motion = {
        startLatLng,
        targetLatLng: { lat: targetLatLng[0], lng: targetLatLng[1] },
        startTimeMs: now,
        targetTimeMs,
        velocity,
        projectionMs: projectionWindow,
        currentLatLng: { lat: startLatLng.lat, lng: startLatLng.lng }
      };
      ensureAnimationLoop();
    }

    let animationHandle = null;

    function ensureAnimationLoop() {
      if (animationHandle !== null) return;
      animationHandle = raf(stepAnimations);
    }

    function stepAnimations() {
      const now = Date.now();
      let shouldContinue = false;
      Object.values(markers).forEach(entry => {
        if (!entry.motion) return;
        const motion = entry.motion;
        const { startLatLng, targetLatLng, startTimeMs, targetTimeMs, velocity, projectionMs } = motion;
        let lat;
        let lng;
        if (now <= targetTimeMs) {
          const span = targetTimeMs - startTimeMs || 1;
          const t = clamp01((now - startTimeMs) / span);
          const eased = easeInOutCubic(t);
          lat = startLatLng.lat + (targetLatLng.lat - startLatLng.lat) * eased;
          lng = startLatLng.lng + (targetLatLng.lng - startLatLng.lng) * eased;
          shouldContinue = true;
        } else {
          const overshoot = now - targetTimeMs;
          if (overshoot < projectionMs) {
            lat = targetLatLng.lat;
            lng = targetLatLng.lng;
            shouldContinue = true;
          } else {
            entry.motion = null;
            lat = targetLatLng.lat;
            lng = targetLatLng.lng;
          }
        }
        motion.currentLatLng = { lat, lng };
        motion.currentTimeMs = now;
        entry.lastLatLng = { lat, lng };
        if (entry.isVisible !== false) {
          entry.marker.setLatLng([lat, lng]);
        }
      });
      if (shouldContinue) {
        animationHandle = raf(stepAnimations);
      } else {
        animationHandle = null;
      }
    }
    function currentInterval() {
      const zoom = map.getZoom();
      let interval = zoom >= LABEL_ZOOM_THRESHOLD ? FOCUSED_INTERVAL_MS : DEFAULT_INTERVAL_MS;
      if (activeRouteFilter) {
        interval = Math.min(interval, FILTERED_INTERVAL_MS);
      }
      return interval;
    }

    function updateRouteLabelVisibility() {
      const container = map.getContainer();
      if (!container) return;
      if (map.getZoom() >= LABEL_ZOOM_THRESHOLD) {
        container.classList.add('map-show-route-labels');
      } else {
        container.classList.remove('map-show-route-labels');
      }
    }

    function formatRefreshInfo(lastSuccess, interval, statusText) {
      const seconds = Math.round(interval / 1000);
      let text = `Odświeżanie mapy: co ${seconds} s`;
      if (!lastSuccess) {
        text += ' | ostatnia aktualizacja: oczekiwanie…';
      } else {
        text += ` | ostatnia aktualizacja: ${lastSuccess.toLocaleTimeString('pl-PL')}`;
      }
      if (activeRouteFilterLabel) {
        text += ` | filtr: linia ${activeRouteFilterLabel}`;
      }
      if (statusText) {
        text += ` | ${statusText}`;
      }
      return text;
    }

    function scheduleNextUpdate() {
      if (refreshTimer) {
        clearTimeout(refreshTimer);
      }
      refreshTimer = setTimeout(updatePositions, currentInterval());
    }

    let lastSuccessfulUpdate = null;
    refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
    updateRouteLabelVisibility();

    routeFilterInput.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        setRouteFilter(routeFilterInput.value);
      }
    });

    routeFilterInput.addEventListener('blur', () => {
      setRouteFilter(routeFilterInput.value);
    });

    routeFilterInput.addEventListener('input', () => {
      if (!routeFilterInput.value.trim()) {
        setRouteFilter('');
      }
    });

    clearFilterButton.addEventListener('click', () => {
      routeFilterInput.value = '';
      setRouteFilter('');
      routeFilterInput.focus();
    });

    locateButton.addEventListener('click', () => {
      if (!navigator.geolocation) {
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'geolokalizacja niedostępna');
        return;
      }
      locateButton.disabled = true;
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'szukam lokalizacji…');
      navigator.geolocation.getCurrentPosition(position => {
        locateButton.disabled = false;
        const { latitude, longitude, accuracy } = position.coords;
        const latlng = [latitude, longitude];
        const targetZoom = Math.max(map.getZoom(), USER_LOCATION_ZOOM);
        map.flyTo(latlng, targetZoom, { duration: 0.8 });
        const radius = Math.max(USER_LOCATION_RADIUS_METERS, accuracy || USER_LOCATION_RADIUS_METERS);
        if (userLocationMarker) {
          userLocationMarker.setLatLng(latlng);
          if (userLocationMarker.setRadius) {
            userLocationMarker.setRadius(radius);
          }
        } else {
          userLocationMarker = L.circle(latlng, {
            radius,
            color: '#1b5e20',
            weight: 2,
            fillColor: '#4caf50',
            fillOpacity: 0.2
          }).addTo(map);
        }
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'zlokalizowano');
      }, err => {
        locateButton.disabled = false;
        console.error('Geolocation error:', err);
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'lokalizacja niedostępna');
      }, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 60000
      });
    });

    function applyPositions(data, interval) {
      if (!Array.isArray(data)) return;
      data.forEach(vehicle => {
        const key = vehicle.id || vehicle.label || `${vehicle.lat},${vehicle.lon}`;
        if (!key) return;
        const lat = Number(vehicle.lat);
        const lon = Number(vehicle.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
        const latlng = [lat, lon];
        const iconData = iconForVehicle(vehicle);
        const popupParts = [];
        if (vehicle.routeId) popupParts.push(`<strong>Linia:</strong> ${vehicle.routeId}`);
        const direction = extractDirection(vehicle);
        if (direction) popupParts.push(`<strong>Kierunek:</strong> ${direction}`);
        if (vehicle.tripId) popupParts.push(`<strong>Trip:</strong> ${vehicle.tripId}`);
        if (vehicle.timestamp) {
          const date = new Date(vehicle.timestamp);
          popupParts.push(`<strong>Czas:</strong> ${date.toLocaleTimeString('pl-PL')}`);
        }
        const popupHtml = popupParts.join('<br>');
        const matchesFilter = matchesActiveFilter(vehicle);
        const tooltipText = iconData.label
          ? direction ? `Linia ${iconData.label} – ${direction}` : `Linia ${iconData.label}`
          : direction || '';
        const sampleTimestamp = vehicleTimestampMs(vehicle, Date.now());
        const existing = markers[key];

        if (existing) {
          existing.lastVehicle = vehicle;
          if (existing.iconKey !== iconData.key) {
            existing.marker.setIcon(iconData.icon);
            existing.iconKey = iconData.key;
          }
          updateMarkerHeading(existing, vehicle.bearing);
          if (existing.routeLabel !== iconData.label || existing.tooltipText !== tooltipText) {
            if (tooltipText) {
              existing.marker.bindTooltip(tooltipText, ROUTE_TOOLTIP_OPTIONS);
            } else if (existing.marker.getTooltip()) {
              existing.marker.unbindTooltip();
            }
            existing.routeLabel = iconData.label;
            existing.tooltipText = tooltipText;
          }
          if (existing.popupHtml !== popupHtml) {
            const popup = existing.marker.getPopup();
            if (popupHtml) {
              if (popup) {
                popup.setContent(popupHtml);
              } else {
                existing.marker.bindPopup(popupHtml);
              }
            } else if (popup) {
              popup.setContent('');
            }
            existing.popupHtml = popupHtml;
          }

          const previousSampleTimestamp = existing.sampleTimestamp;
          setMarkerVisibility(existing, matchesFilter);
          scheduleMotion(existing, latlng, sampleTimestamp, previousSampleTimestamp, interval);
          existing.sampleTimestamp = sampleTimestamp;
          return;
        }

        const marker = L.marker(latlng, { icon: iconData.icon });
        if (popupHtml) {
          marker.bindPopup(popupHtml);
        }
        if (tooltipText) {
          marker.bindTooltip(tooltipText, ROUTE_TOOLTIP_OPTIONS);
        }
        const entry = {
          marker,
          lastLatLng: { lat: latlng[0], lng: latlng[1] },
          isVisible: matchesFilter,
          lastVehicle: vehicle,
          iconKey: iconData.key,
          routeLabel: iconData.label,
          tooltipText,
          popupHtml,
          sampleTimestamp: undefined,
          motion: null,
          heading: null
        };
        markers[key] = entry;
        if (matchesFilter) {
          marker.addTo(map);
        }
        updateMarkerHeading(entry, vehicle.bearing);
        scheduleMotion(entry, latlng, sampleTimestamp, entry.sampleTimestamp, interval);
        entry.sampleTimestamp = sampleTimestamp;
      });
      if (lastServerTimestamp) {
        const parsed = Date.parse(lastServerTimestamp);
        lastSuccessfulUpdate = Number.isNaN(parsed) ? new Date() : new Date(parsed);
      } else {
        lastSuccessfulUpdate = new Date();
      }
    }

    async function updatePositions() {
      if (isFetching) {
        pendingImmediateUpdate = true;
        return;
      }
      isFetching = true;
      const interval = currentInterval();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, interval, 'pobieranie…');
      try {
        const options = { cache: 'no-store', headers: {} };
        if (lastETag) {
          options.headers['If-None-Match'] = lastETag;
        }
        const res = await fetch('/positions', options);
        if (res.status === 304) {
          refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, interval);
          return;
        }
        const data = await res.json();
        lastETag = res.headers.get('ETag') || lastETag;
        lastServerTimestamp = res.headers.get('X-Feed-Updated-At') || lastServerTimestamp;
        const parsedData = Array.isArray(data) ? data : [];
        applyPositions(parsedData, interval);
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, interval);
      } catch (err) {
        console.error('Błąd podczas pobierania pozycji pojazdów:', err);
        refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval(), 'błąd pobierania');
      } finally {
        isFetching = false;
        if (pendingImmediateUpdate) {
          pendingImmediateUpdate = false;
          setTimeout(updatePositions, 0);
        } else {
          scheduleNextUpdate();
        }
      }
    }

    map.on('zoomend', () => {
      updateRouteLabelVisibility();
      refreshInfo.textContent = formatRefreshInfo(lastSuccessfulUpdate, currentInterval());
      updatePositions();
    });

    updatePositions();
  </script>
</body>
</html>
